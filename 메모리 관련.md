**프로젝트 소개**
-------

안드로이드 앱을 개발하다보면 메모리 부족 문제에 시달리기 쉽습니다.
그러므로 앱을 개발하는데 있어서 메모리 관리는 정말 중요합니다.
메모리의 정의부터 안드로이드에서의 메모리 관리까지 정리해보았습니다.
내용중에 메모리와 상관없는 내용이 있을 수도 있습니다. 그런 내용은 제가 공부하면서 궁금한 점이 꼬리에 꼬리를 물었기때문에 같이 정리해서 그렇습니다.
그런 내용은 Skip 하셔도 됩니다!

프로젝트는 지속적으로 추가 될 예정입니다. 상단의 Star, Watching 버튼을 클릭하시면 구독 알림을 받으실 수 있습니다 :)


----------


**목차**
--

 - [프로젝트 소개](#프로젝트-소개)
 - [목차](#목차)
 - [전체 플로우](#전체-플로우)
  - [메모리란?](#메모리란?)
  - [자바에서의 메모리 동작](#자바에서의-메모리-동작)
  - [스레드의 메모리](#스레드의-메모리)
  - [GC(가비지 컬렉터)](#GC(가비지-컬렉터))
  - [static변수 (정적변수)](#static변수-(정적변수))
     - [static의 사용법](#static의-사용법)
     - [static class와 싱글톤 패턴](#static-class와-싱글톤-패턴)
  - [WeakReference](#WeakReference)
     - [WeakReference에서의 메모리 회수 대상 기준](#WeakReference에서의-메모리-회수-대상-기준)
  - [안드로이드 메모리는 어떻게 동작하는가?](#안드로이드-메모리는-어떻게-동작하는가?)
  - [안드로이드에서의 메모리 릭](#안드로이드에서의-메모리-릭)


----------

**전체 플로우**
----------


**메모리란?**
------------------------------------------


----------
메모리는 프로그램을 실행하기 위한 데이터 및 명령어를 저장하는 공간이다. 

메모리 구조를 공부하는 이유는

1. 같은 기능의 프로그램이더라도 메모리 관리에 따라 성능이 좌우된다. 

   -> 메모리 관리가 되지 않은 경우 속도저하 현상이나 튕김 현상등이 발생할 수 있다.
   
2. 한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해서이다.






**자바에서의 메모리 동작**
--------

자바 응용프로그램이 시작되면, JVM은 OS로부터 프로그램 수행에 필요한 메모리를 할당 받고, 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

즉, 자바 프로그램은 JVM이라는 프로그램만 있으면 실행이 가능한데, JVM이 OS에게서 메모리 사용 권한을 할당받고 JVM이 자바 프로그램을 호출하여 실행한다.

OS로부터는 독립되었지만(C는 OS에 종속되어 실행된다. 반면 자바는 종속되지 않으므로 OS종류에 영향을 받지 않고 돌아갈 수 있다)

JVM을 실행시키고 다시 JVM이 프로그램을 실행시키는 방식이다 보니 OS에 직접 제어 받는 방식보다는 속도면에서 느리다는 단점이 있다.

응용프로그램을 시작할때의 과정을 조금 더 자세하게 살펴보면

1. 실행될 클래스 파일을 메모리에 로드한 후 초기화 작업을 수행한다.

2. 메소드와 클래스 변수들을 해당 메모리에 배치한다.

3. 클래스 로드가 끝난 후, JVM은 main()함수를 찾아 지역변수, 객체변수, 참조변수를 스택에 쌓는다.

4. 다음 라인을 진행하면서 상황에 맞는 작업을 수행한다. (함수 호출, 객체 할당 등)

----------
참고로 JVM(자바 가상 머신)은 자바 바이트 코드를 실행할 수 있는 주체로, JAVA와 OS사이의 중계자 역할을 하며 메모리 관리를 GC로 자동으로 해준다.

운영체제와 플랫폼 종류에 의존적이지 않고 독립적으로 JAVA프로그램이 실행되게 해주는 역할을 한다.

----------
JVM은 OS로부터 프로그램이 필요로 하는 메모리를 할당받는데, 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.

(이렇게 여러 영역으로 나누어 관리하는 이유는 일상생활 속에서도 용도에 따라 물건을 나누어 다른 장소에 관리하는게 편한것과 같은 맥락이다.)

크게 세가지로 나눌 수 있다. (메소드 영역/스택 영역/힙 영역)

1. 메소드 영역 : 이 영역에는 클래스 파일의 바이트 코드가 로드되는 곳이다.

   JVM이 뭔가를 실행하려면 먼저 그 바이트 코드들이 메모리 공간에 저장되어 있어야 한다.
                
   JVM은 main() 즉, 메인 메소드를 호출하는 것으로 시작하는데, 이때부터 프로그램이 시작된다고 볼 수 있다.
                
   우리가 메인 메소드에서 사용하는 클래스와 static변수들은 이 메소드 영역에 올라온다.
                
   즉, 메소드 영역에 저장되는 바이트 코드는 '프로그램의 흐름을 구성하는 바이트 코드'이다.
                
   이 바이트 코드는 자바 컴파일러에 의해서 컴파일 된 애들이기 때문에, 사실상 전체 바이트 코드가 이 영역에 올라간다고 할 수 있다.
   
   
2. 스택 영역 : 메소드 호출시마다 해당 메소드만을 위한 공간(프레임)이 생성되는데 바로 이 영역이다.

   메서드 안에서 사용되어지는 지역변수나 매개변수값들을 저장한다. 그리고 메서드 호출이 끝나면 그 메서드를 위해 준비했던 모든 변수가 스택에서 제거된다.

   즉, 해당 프레임이 삭제된다.

   쉽게 말해 스택 영역에는 프로그램의 실행 과정에서 '임시'로 할당되고, 그게 끝나면 바로 소멸되는 것들이 저장된다.

   -> 즉, 메소드가 호출될때마다 그 메소드의 지역변수를 준비하고 메소드 호출이 끝나면 그 메소드를 위해 준비했던 모든 변수가 스택에서 제거된다.
   
   예제를 통해 살펴보자.
   
   ```java
   public void main() {
        int a = 20;    
        m1(a); // 20
    }

    public void m1(int a) {
      ++a;
      m2(a); // 21
    }

    public void m2(int a) {
      ++a;
     System.out.println(a); // 22
    }
   ```
   
   이 경우, 스택영역에는
   
   m2() // a = 22
   
   m1() // a = 21
   
   main() // a = 20
   
   이런 식으로 프레임이 생성된다.
   
   그리고 m2()에서 System.out.println(a); 가 호출되므로써 메소드가 종료되면 스택영역은
   
   m1() // a = 21
   
   main() // a = 20
   
   으로 바뀌게 된다. (m2()프레임이 종료된다.)
   
   
 3. 힙 영역 : new 연산자를 통해 생성된 인스턴스 변수(ex. 객체 또는 배열, 리스트)의 메모리는 모조리 힙 영역에 저장된다.
 
 스택 영역에 저장되는 로컬 변수, 매개변수와 달리 힙 영역에 저장되는 메모리는 메소드 호출이 끝나도 사라지지 않고 유지된다.
 
즉, 주소를 잃어버려 가비지가 되어 GC(가비지 컬렉터)에 의해 지워질때까지 또는 JVM이 종료될때까지 사라지지 않고 유지된다.

인스턴스의 소멸방법과 소멸 시점은 지역변수(스택영역에 할당되는 애들)과는 다르다.

조금 더 자세하게 살펴보자면, 

8가지 원시타입(byte, short, int, long, float ..)을 제외한 그 외의 타입으로 정의된 변수들은 모조리 레퍼런스 변수(참조변수)라고 하는데,

이런 참조변수들은 실행될때마다 많은 데이터들을 스택 영역에 넣었다 뺐다 하는 것이 매우 비효율적이라서

힙 영역에 진짜값을 저장해놓고, 스택 영역에는 간단하게 그 주소만 저장하는 방식으로 움직이고 있다.

즉, 힙 영역에는 실제 인스턴스 변수가 가리키는 값들이 저장되어 있는 것이다.

GC(가비지 컬렉터)는 힙 메모리 영역을 다룬다.


**스레드의 메모리**
-------- 
 
스레드는 프로세스 안에 존재하는 실행 흐름을 말하는것으로,

참고로 프로세스 내부에서 돌아가는 모든 스레드들은 스택 영역을 제외하고 프로세스의 메소드 영역과 힙 영역을 공유한다. 

따라서 이 두 영역을 통해서 데이터를 공유할 수 있는 것이다. (스레드 간의 통신이 가능한 이유)

즉, 동일한 프로세스 내부에 존재하는 스레드 A, B가 통신하기 위해 힙 영역에 메모리 공간을 할당하고, 두 스레드가 자유롭게 접근한다고 생각하면 된다.

반면에,스택 영역은 스레드 별로 독립적으로 존재한다. 이유는 메소드의 호출을 위해서 사용되는 메모리 공간이 스택 영역이기 때문이다.

즉, 개별 메소드 호출이 필요하기 때문이다.




**GC(가비지 컬렉터)**
-------- 
 
GC(가비지 컬렉터)에 대해서 살펴보기 전에, 주소를 잃어버려서 사용할 수 없는 메모리 즉, 정리되지 않은 메모리가 어떤 경우인지 살펴보도록 하자.

```java
 int[] array = new int[3];  // (1)
     // array는 int 타입의 3칸 짜리 배열을 가리키는 주소
    array[0] = 0;

    array[1] = 10;

    array[2] = 20;

    ...

    array = new String[] {'하하', ''호호', '히히', '후후', '헤헤'};  // (2)
```

즉, (1)에서 만들어진 int 타입을 계속 사용하다가 (2)에서 새로운 String 타입의 배열을 가리키게 한다.

이럴 경우 (1)인 경우의 int 타입 3칸짜리 배열은 다시 사용할 수 없다. 주소를 잃어버렸기 때문이다.

이런 식으로 주소를 잃어버려 더이상 사용할 수 없는 메모리가 바로 '정리되지 않은 메모리' 이고 이것을 자바에서는 쓰레기 즉, 가비지라고 부른다.

가비지 컬렉터는 이러한 상황 즉, 메모리가 부족할때 쓰레기(가비지)를 정리해주는 프로그램을 말한다.

이런 가비지들은 유효한 메모리가 아니다. 가비지들은 정리되지 않은 채로 남겨져 있으므로 사용되지도 않으면서 자리를 차지하고 있기 때문에

가비지 컬렉터는 가비지를 다른 용도로 사용할 수 있게 '메모리 해제'를 해준다.

JVM은 메모리를 부여받고 열심히 프로그램을 실행하다가 메모리가 부족해지는 순간이 오면 OS에게 추가로 메모리를 더 요청하게 되는데.

바로 이때 가비지 컬렉터가 실행된다. 또한 JVM이 한가할때 가비지 컬렉터가 실행되기도 한다.

JVM이 종료되면 당연히 사용하던 모든 메모리는 OS에게 반납된다.


**static변수 (정적변수)**
-------- 
static변수에 대해서 자세하게 살펴보자.

static은 최초 빌드됨과 동시에 메모리에 자동으로 로딩된다. (메소드 영역에 생성된다.)

즉, 메모리 할당을 한번만 하게 되는 것이다.

static을 사용한다는 의미는 모든 객체가 '공유'한다는 의미이다. 한번 로딩된 클래스는 특별한 일이 발생하지 않는 이상 메모리상에서 객체를 생성할 수 있도록 메모리에 상주하게 되는데, 이때 static은 이 시점에 메모리에 올라가면서 필요한 동작을 처리한다.

즉, static은 객체의 생성과는 관계없이 클래스가 로딩되는 시점에 메모리에 올라간다. 

(참고로 메소드 영역은 JVM이 동작해서 클래스가 로딩될 때 생성되고, 클래스 내의 모든 스레드가 공유하는 영역이다.)


static의 예제를 살펴보자.

```java
 class Work {
      static int shareWork = 0;

      int privateWork = 0;
      
      void doWork() {
        System.out.println("공통과제 : " + shareWork + "번" + ", 개인과제 : " + privateWork + "번 수행했습니다.");
      }


    public class Person {
      public static void main(String[] args) {
         Work w1 = new Work();

         Work w2 = new Work();

         w1.doWork(); // shareWork = 1번, privateWork = 1번

         w2.doWork(); // shareWork = 2번, privateWork = 1번
     }
}
```

위 코드를 살펴보면, static이 붙은 변수는 고정 메모리이므로 공유하는 것을 알 수 있다.
(생성할때마다 힙 영역에 올라가는 것이 아니라 이미 메소드 영역에 저장되어 있는 고정 메모리이다.)

static은 객체를 생성하지 않고 사용하기 때문에 속도가 빠르다.


**static의 사용법**
-------- 
그러나, static을 무분별하게 사용하면 메모리 릭의 원인이 된다.

static은 클래스가 생성될 때 메모리를 할당받고 프로그램 종료 시점에 반환되므로, 사용하지 않아도 메모리가 계속 할당되어있다.

반면에 객체 생성으로 만들어진 인스턴스는 참조되지 않으면 GC에 의해 소멸되므로(힙 영역에 상주) 메모리 낭비를 방지 할 수 있다.

그러므로 static은 위의 예제처럼

1. 공유되는 값에 사용하거나

2. final과 함께 사용하여 절대적으로 바뀌지 않는 값으로써 사용한다.

ex. 하루가 24시간인것은 바뀌지 않으므로 final static으로 선언한다.



**static class와 싱글톤 패턴**
-------- 

이쯤되면 static class과 싱글톤 패턴이 비슷하게 보일텐데 보통 싱글톤 패턴을 사용한다.

이유는 다양하게 있지만, 일단 static은 클래스가 최초 로딩됨과 동시에 메모리에 올라가게 된다.

반면에 싱글톤은 초기 호출할때 그때부터 메모리에 올라가므로 싱글톤이 static class보다 메모리 효율이 더 좋다고 할 수 있다.



**WeakReference**
-------- 

WeakReference에 대해서 살펴보자.

모든 WeakReference는 메모리 릭이 발생하기 전에 가비지 콜렉터에 의해 수집되게 된다.

가비지 컬렉터는 WeakReference 객체를 다른 객체와 달리 회수해야 하는 애로 취급하기 때문이다.

즉, WeakReference에 의해 참조된 객체는 가비지 콜렉터가 발생하기 전까지는 객체에 대한 참조를 유지하지만, 일단 가비지 콜렉터가 발생하면 무조건 수거된다.

그런데 주의할 점이 있다.

가비지 콜렉터는 null이 된 즉, 주소를 잃어버려 더이상 사용할 수 없는 메모리를 정리하는 프로그램으로써, 사용이 끝난 후 (ex. onDestroy())에서

WeakReference로 선언했던 객체를 null로 해줘야 한다. 그래야 주소를 잃어버린게 되서 가비지 콜렉터가 수집할 수 있다.

```java
public class TimeHandler extends Handler {

       private WeakReference<MyActivity> ref;

       TimeHandler(MyActivity act) {
         ref = new WeakReference<>(act);
       }

       @Override
       public void handleMessage(final Message msg) {
         final MyActivity act = ref.get(); // 캡슐화된 객체를 get()메서드를 통해 가져온다.

         if(act != null) { // 아직 살아있음
            act.mTotalTime = 3000; // 이런 식으로 변수에 접근 가능
       }
   }
```


이 상태에서 만약에 ref = null;을 해줄 경우 Weak reachable 객체가 되는데, 이때는 무조건 가비지 컬렉터에 의해 메모리가 회수된다.

(그러나 GC가 실제로 언제 객체를 회수할지는 GC알고리즘에 따라 모두 다르므로, GC가 수행될때마다 반드시 메모리까지 회수된다고 보장하지는 않는다.)

그러므로 사용이 끝났다면 꼭 null을 대입해줘야 한다.




**WeakReference에서의 메모리 회수 대상 기준**
-------- 

GC는 객체가 가비지인지 판별하기 위해서 reachability라는 개념을 사용한다.

어떤 객체에 유효한 참조가 있으면 'reachable', 없으면 'unreachable'로 나누는데, unreachable 객체를 가비지로 간주한다.

GC 입장에서는 unreachable 객체와 Weakly Reachable 객체가 같은 의미라고 생각하여 가비지 객체로 간주, GC를 수행할때마다 회수 대상이 되는데

Strongly reachable은 정책에 의해 GC여부가 결정되는 것이므로 Weakly reachable에 비해 회수 당할 확률이 낮다.

그런데 사실 WeakReference 객체 자체는 Weakly reachable 객체가 아니라 Strongly reachable 이다.

그러므로 WeakReference 객체 자체는 GC에 의해 메모리 회수 된다고 꼭 보장할 수 없는 것이다.

그러므로 사용이 끝난 경우엔 null을 꼭 대입해줘야 한다.

null이면 가비지로 판명되어 다른 객체들과 함께 메모리 회수 대상이 될 수 있다.




**안드로이드 메모리는 어떻게 동작하는가**
-------- 

안드로이드 단말에는 모든 앱에서 공통으로 사용하는 프레임워크 클래스, 리소스, 네이티브 라이브러리 등이 있다.
안드로이드는 메모리를 절약하려고 이런 것을 공유 메모리에 올려두고 앱 사이에서 함께 사용한다.
공유 메모리는 메모리 사용량을 분석할때 프로세스에 균등하게 1/n으로 나누어 적용한다.

반대로 전용 메모리는 특정 앱 내부에서 사용되고 다른 앱에서 사용할 수 없는 영역이다.

즉, 하나의 앱이 단말의 메모리에서 사용할 수 있는 메모리 양은 한정적이다. 그러므로 메모리를 할당하고 해제하지 않거나
쓸데없이 메모리를 낭비하면 메모리 부족으로 앱이 죽을 수도 있다.


**안드로이드에서의 메모리 릭**
-------- 


일반적으로 런타임에서 모든 메모리 할당과 해제(GC)를 처리한다.

자세히 살펴보자. 어플리케이션은 동작을 위해 메모리가 필요하다. 메모리릭이란 어플리케이션이 사용이 끝난 메모리를 반환하지 않는 것을 말한다.

보통 릭이 발생하면, 사용한 메모리는 반환하지 않은 채 추가로 필요한 메모리를 시스템에 요청하기 대문에 사용하는 메모리의 양이 계속해서 증가한다.

이 과정이 계속되면, 최악의 경우 OOM(Out Of Memory)를 발생시키고 어플리케이션이 강제 종료되면서 어플리케이션에 할당되었던 메모리가 시스템으로 회수된다.


자바는 C/C++과 달리 메모리를 명시적으로 해제(시스템에 반환)하지 않고, GC(가비지 콜렉션)이 그 역할을 대신한다.

GC가 사용하지 않는 자원을 스스로 수집하는 것은 맞지만, 이는 사용하지 않는 메모리가 성공적으로 모두 회수될때의 얘기이다.

다시 말해, 어플리케이션이 사용하지 않는 메모리라도 GC 실행시 시스템이 사용중인 메모리로 판단하고 회수하지 않는다면, 여전히 메모리 릭은 
발생할 수 있다. 


안드로이드의 메모리 릭 경우를 살펴보자.

안드로이드 앱의 메모리가 누수되는 과정은 대체로 자바와 같다. 다만, 안드로이드 플랫폼의 특징에서 오는 몇 가지 차이점이 있다.

먼저 시스템이 앱에 할당하는 메모리 제한이 있다. 이 제한값은 단말의 램 크기에 따라 달라진다. 

그러므로 어플리케이션이 사용할 수 있는 최대 메모리 크기를 넘어서면 OOM이 발생한다. 

모바일 기기들은 페이징을 하지 않으므로 안드로이드 앱에서 사용하는 모든 객체는 RAM에 상주한다. 

안드로이드에서 발생하는 릭은 보통 액티비티나 이미지와 함께 발생한다. 액티비티와 이미지가 가장 크게 메모리를 차지하기 때문이다.

액티비티는 안드로이드 앱이 운용하는 객체중에 가장 큰 객체이며, 사용자와 상호작용을 통해 동작하는 안드로이드 앱의 특성상 가장 빈번하게 생성/삭제 된다. 

이미지의 경우 최근에 출시되는 단말들의 해상도는 집의 티비나 모니터보다 해상도가 높다. 해상도가 높은 만큼 이미지는 많은 메모리를 차지하므로 잘못 관리하면 메모리 문제를 만나기 쉽다.
















